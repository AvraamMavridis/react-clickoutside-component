<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" type="text/css" href="smallgrid.css" media="screen">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js"></script>

  <title>Avraam Mavridis</title>
</head>

<body class="center-container">
    <div class="center-item">
      <div class="container">
       <div class="col"> Type a programming language  : </div>
       <div class="col"  id="app"></div>
     </div>
   </div>
</body>
<script>
'use strict';

var _temporalUndefined = {};

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var AutoComplete = _temporalUndefined;

function _temporalAssertDefined(val, name, undef) { if (val === undef) { throw new ReferenceError(name + ' is not defined - temporal dead zone'); } return true; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

AutoComplete = (function (_React$Component) {
  _inherits(_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete, _React$Component);

  _createClass(_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete, null, [{
    key: 'defaultProps',
    value: {
      inputStyle: {
        width: '100px'
      },
      optionStyle: {
        borderBottom: '1px solid grey'
      },
      optionsContainerStyle: {
        width: '100px',
        backgroundColor: 'White',
        position: 'absolute',
        borderLeft: '1px solid black',
        borderRight: '1px solid black',
        margin: '2px 0px',
        padding: '0px 1px'
      },
      selectedStyle: {
        backgroundColor: 'LightSkyBlue',
        borderBottom: '1px solid grey'
      },
      onOpen: function onOpen() {
        return null;
      },
      onClose: function onClose() {
        return null;
      },
      onSelect: function onSelect() {
        return null;
      }
    },
    enumerable: true
  }]);

  function AutoComplete() {
    _classCallCheck(this, _temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete);

    _React$Component.call(this);
    this.state = {
      options: [],
      selectedIndex: -1,
      isOpen: false,
      value: ''
    };
    this.initKeyEvents();
  }

  /**
   * Initialize key events
   *
   * @method initKeyEvents
   *
   * @return { void }
   */

  (_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete).prototype.initKeyEvents = function initKeyEvents() {
    var that = _temporalUndefined;

    that = this;
    document.addEventListener('keydown', function (e) {
      if (e.which === 40 && (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.selectedIndex + 1 < (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.options.length) {
        (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).setState({
          selectedIndex: (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.selectedIndex + 1
        });
      } else if (e.which === 38 && (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.selectedIndex - 1 >= -1) {
        (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).setState({
          selectedIndex: (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.selectedIndex - 1
        });
      } else if (e.which === 13 && (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.isOpen) {
        (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).setState({
          value: (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.options[(_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.selectedIndex],
          options: [],
          isOpen: false
        });

        (_temporalAssertDefined(that, 'that', _temporalUndefined) && that).props.onSelect((_temporalAssertDefined(that, 'that', _temporalUndefined) && that).state.value);
      }
    });
  };

  /**
   * Callback for onchange event in the input
   *
   * @method onType
   *
   * @param  { object } e Event
   *
   * @return { void }
   */

  (_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete).prototype.onType = function onType(e) {
    var _opt = _temporalUndefined;
    _opt = this.props.options.filter(function (opt) {
      return opt.indexOf(e.target.value) > -1;
    });
    this.setState({
      options: !!e.target.value ? _temporalAssertDefined(_opt, '_opt', _temporalUndefined) && _opt : [],
      value: e.target.value,
      isOpen: Boolean((_temporalAssertDefined(_opt, '_opt', _temporalUndefined) && _opt).length && e.target.value),
      selectedIndex: -1
    });
  };

  /**
   * Sets the selected option on click
   *
   * @method onOptionClick
   *
   * @param  { object }  e  Event
   *
   * @return { void }
   */

  (_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete).prototype.onOptionClick = function onOptionClick(e) {
    this.setState({
      value: e.target.textContent,
      options: [],
      isOpen: false,
      selectedIndex: -1
    });
    this.props.onSelect(this.state.value);
  };

  /**
   * [componentWillUpdate description]
   *
   * @method componentWillUpdate
   *
   * @param  { object } nextProps
   * @param  { object } nextState
   *
   * @return { void }
   */

  (_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete).prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    // use the literal form of the literal because of the undefined case
    this.isClosed = this.isClosed || 'true';
    if (nextState.isOpen && this.isClosed === 'true') {
      nextProps.onOpen();
      this.isClosed = 'false';
    } else if (!nextState.isOpen && this.isClosed === 'false') {
      nextProps.onClose();
      this.isClosed = 'true';
    }
  };

  /**
   * Render Element on the DOM
   *
   * @method render
   *
   * @return { React Element }
   */

  (_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete).prototype.render = function render() {
    var _this = this;

    var inputStyle = _temporalUndefined;
    var optionStyle = _temporalUndefined;
    var optionsContainerStyle = _temporalUndefined;
    var selectedStyle = _temporalUndefined;

    inputStyle = _extends({}, this.props.inputStyle);
    optionStyle = _extends({}, this.props.optionStyle);
    optionsContainerStyle = _extends({}, this.props.optionsContainerStyle);
    selectedStyle = _extends({}, this.props.selectedStyle);
    return React.createElement(
      'div',
      null,
      React.createElement('input', { ref: 'inputElement', style: _temporalAssertDefined(inputStyle, 'inputStyle', _temporalUndefined) && inputStyle, onChange: this.onType.bind(this), type: 'text', value: this.state.value }),
      React.createElement(
        'ul',
        { tabIndex: '0', style: this.state.options.length ? _temporalAssertDefined(optionsContainerStyle, 'optionsContainerStyle', _temporalUndefined) && optionsContainerStyle : { display: 'none' } },
        this.state.options.map(function (r, index) {
          return React.createElement(
            'li',
            { style: _this.state.selectedIndex === index ? _temporalAssertDefined(selectedStyle, 'selectedStyle', _temporalUndefined) && selectedStyle : _temporalAssertDefined(optionStyle, 'optionStyle', _temporalUndefined) && optionStyle, onClick: _this.onOptionClick.bind(_this),
              tabIndex: index, className: _this.state.selectedIndex === index ? 'selected' : '' },
            ' ',
            r,
            ' '
          );
        })
      )
    );
  };

  return _temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete;
})(React.Component);

var c = ['java', 'javascript', 'css', 'postcss'];

var cStyle = {
  width: '300px'
};

var open = function open() {
  console.log('open');
};

var close = function close() {
  console.log('close');
};

var select = function select(val) {
  console.log(val);
};

ReactDOM.render(React.createElement(_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete, { options: c, onOpen: open, onClose: close, onSelect: select }), document.getElementById('app'));

var c = ['java', 'javascript', 'css', 'postcss'];

var cStyle = {
  width: '300px'
};

var open = function open() {
  console.log('open');
};

var close = function close() {
  console.log('close');
};

var select = function select(val) {
  console.log(val);
};

ReactDOM.render(React.createElement(_temporalAssertDefined(AutoComplete, 'AutoComplete', _temporalUndefined) && AutoComplete, { options: c, onOpen: open, onClose: close, onSelect: select }), document.getElementById('app'));
  </script>
